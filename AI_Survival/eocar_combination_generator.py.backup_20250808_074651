"""
EOCARç»„åˆç”Ÿæˆå™¨ï¼ˆEOCAR Combination Generatorï¼‰

åŸºäºEOCATRç»éªŒè¿›è¡Œç»„åˆåˆ†æï¼Œç”Ÿæˆå€™é€‰è§„å¾‹çš„æ ¸å¿ƒæ¨¡å—ã€‚
å®ç°äº†15ç§EOCARå…ƒç´ ç»„åˆç±»å‹ï¼ˆC41+C42+C43+C44ï¼‰ï¼Œé€šè¿‡å±æ€§æ³›åŒ–ç”Ÿæˆé«˜è´¨é‡å€™é€‰è§„å¾‹ã€‚

ä¸»è¦åŠŸèƒ½ï¼š
1. EOCARå…ƒç´ ç»„åˆåˆ†æ
2. å±æ€§åˆ†è§£ä¸æ³›åŒ–
3. å€™é€‰è§„å¾‹ç”Ÿæˆ
4. è§„å¾‹è´¨é‡è¯„ä¼°

ä½œè€…ï¼šAIç”Ÿå­˜æ¸¸æˆé¡¹ç›®ç»„
ç‰ˆæœ¬ï¼š1.0.0
"""

import time
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Tuple, Set
from enum import Enum
from collections import defaultdict, Counter
from scene_symbolization_mechanism import (
    EOCATR_Tuple, SymbolicEnvironment, SymbolicObjectCategory, 
    SymbolicAction, SymbolicCharacteristics, SymbolicResult, SymbolicTool
)


class CombinationType(Enum):
    """EOCATRç»„åˆç±»å‹æšä¸¾ï¼ˆåŒ…å«å·¥å…·Tçš„å®Œæ•´ç»„åˆï¼‰"""
    # å•å…ƒç´ +ç»“æœ (5ç§)
    E_R = "environment_result"        # ç¯å¢ƒ->ç»“æœ
    O_R = "object_result"            # å¯¹è±¡->ç»“æœ
    C_R = "characteristics_result"    # ç‰¹å¾->ç»“æœ
    A_R = "action_result"            # åŠ¨ä½œ->ç»“æœ
    T_R = "tool_result"              # å·¥å…·->ç»“æœ
    
    # åŒå…ƒç´ +ç»“æœ (10ç§)
    E_O_R = "environment_object_result"           # ç¯å¢ƒ+å¯¹è±¡->ç»“æœ
    E_C_R = "environment_characteristics_result"  # ç¯å¢ƒ+ç‰¹å¾->ç»“æœ
    E_A_R = "environment_action_result"           # ç¯å¢ƒ+åŠ¨ä½œ->ç»“æœ
    E_T_R = "environment_tool_result"             # ç¯å¢ƒ+å·¥å…·->ç»“æœ
    O_C_R = "object_characteristics_result"       # å¯¹è±¡+ç‰¹å¾->ç»“æœ
    O_A_R = "object_action_result"               # å¯¹è±¡+åŠ¨ä½œ->ç»“æœ
    O_T_R = "object_tool_result"                 # å¯¹è±¡+å·¥å…·->ç»“æœ
    C_A_R = "characteristics_action_result"       # ç‰¹å¾+åŠ¨ä½œ->ç»“æœ
    C_T_R = "characteristics_tool_result"         # ç‰¹å¾+å·¥å…·->ç»“æœ
    A_T_R = "action_tool_result"                 # åŠ¨ä½œ+å·¥å…·->ç»“æœ
    
    # ä¸‰å…ƒç´ +ç»“æœ (10ç§)
    E_O_C_R = "environment_object_characteristics_result"  # ç¯å¢ƒ+å¯¹è±¡+ç‰¹å¾->ç»“æœ
    E_O_A_R = "environment_object_action_result"           # ç¯å¢ƒ+å¯¹è±¡+åŠ¨ä½œ->ç»“æœ
    E_O_T_R = "environment_object_tool_result"             # ç¯å¢ƒ+å¯¹è±¡+å·¥å…·->ç»“æœ
    E_C_A_R = "environment_characteristics_action_result"  # ç¯å¢ƒ+ç‰¹å¾+åŠ¨ä½œ->ç»“æœ
    E_C_T_R = "environment_characteristics_tool_result"    # ç¯å¢ƒ+ç‰¹å¾+å·¥å…·->ç»“æœ
    E_A_T_R = "environment_action_tool_result"             # ç¯å¢ƒ+åŠ¨ä½œ+å·¥å…·->ç»“æœ
    O_C_A_R = "object_characteristics_action_result"       # å¯¹è±¡+ç‰¹å¾+åŠ¨ä½œ->ç»“æœ
    O_C_T_R = "object_characteristics_tool_result"         # å¯¹è±¡+ç‰¹å¾+å·¥å…·->ç»“æœ
    O_A_T_R = "object_action_tool_result"                  # å¯¹è±¡+åŠ¨ä½œ+å·¥å…·->ç»“æœ
    C_A_T_R = "characteristics_action_tool_result"         # ç‰¹å¾+åŠ¨ä½œ+å·¥å…·->ç»“æœ
    
    # å››å…ƒç´ +ç»“æœ (5ç§)
    E_O_C_A_R = "environment_object_characteristics_action_result"  # ç¯å¢ƒ+å¯¹è±¡+ç‰¹å¾+åŠ¨ä½œ->ç»“æœ
    E_O_C_T_R = "environment_object_characteristics_tool_result"    # ç¯å¢ƒ+å¯¹è±¡+ç‰¹å¾+å·¥å…·->ç»“æœ
    E_O_A_T_R = "environment_object_action_tool_result"             # ç¯å¢ƒ+å¯¹è±¡+åŠ¨ä½œ+å·¥å…·->ç»“æœ
    E_C_A_T_R = "environment_characteristics_action_tool_result"    # ç¯å¢ƒ+ç‰¹å¾+åŠ¨ä½œ+å·¥å…·->ç»“æœ
    O_C_A_T_R = "object_characteristics_action_tool_result"         # å¯¹è±¡+ç‰¹å¾+åŠ¨ä½œ+å·¥å…·->ç»“æœ
    
    # å…¨å…ƒç´ +ç»“æœ (1ç§)
    E_O_C_A_T_R = "full_eocatr_result"            # å®Œæ•´EOCATR->ç»“æœ


@dataclass
class CandidateRule:
    """å€™é€‰è§„å¾‹æ•°æ®ç±»"""
    rule_id: str                      # è§„å¾‹ID
    combination_type: CombinationType  # ç»„åˆç±»å‹
    condition_elements: List[str]     # æ¡ä»¶å…ƒç´ åˆ—è¡¨
    condition_text: str               # æ¡ä»¶æ–‡æœ¬æè¿°
    expected_result: Dict[str, Any]   # é¢„æœŸç»“æœ
    
    # ç”Ÿæˆä¿¡æ¯
    source_experiences: List[str] = field(default_factory=list)  # æºç»éªŒID
    generation_time: float = field(default_factory=time.time)    # ç”Ÿæˆæ—¶é—´
    abstraction_level: int = 0        # æŠ½è±¡å±‚æ¬¡ (0=å…·ä½“, 1=å±æ€§æ³›åŒ–, 2=é«˜åº¦æŠ½è±¡)
    
    # è´¨é‡æŒ‡æ ‡
    confidence: float = 0.1           # åˆå§‹ç½®ä¿¡åº¦
    support_count: int = 1            # æ”¯æŒç»éªŒæ•°é‡
    contradict_count: int = 0         # çŸ›ç›¾ç»éªŒæ•°é‡
    generalization_score: float = 0.0 # æ³›åŒ–å¾—åˆ†
    
    # éªŒè¯çŠ¶æ€
    validation_attempts: int = 0      # éªŒè¯å°è¯•æ¬¡æ•°
    validation_successes: int = 0     # éªŒè¯æˆåŠŸæ¬¡æ•°
    last_validation: float = 0.0      # æœ€åéªŒè¯æ—¶é—´
    status: str = "candidate"         # çŠ¶æ€: candidate/validated/rejected
    
    # ä½¿ç”¨ç»Ÿè®¡
    activation_count: int = 0         # è§„å¾‹æ¿€æ´»æ¬¡æ•°
    last_activation: float = 0.0      # æœ€åæ¿€æ´»æ—¶é—´
    
    def get_success_rate(self) -> float:
        """è·å–éªŒè¯æˆåŠŸç‡"""
        if self.validation_attempts == 0:
            return 0.0
        return self.validation_successes / self.validation_attempts
    
    def get_support_ratio(self) -> float:
        """è·å–æ”¯æŒæ¯”ä¾‹"""
        total = self.support_count + self.contradict_count
        if total == 0:
            return 0.0
        return self.support_count / total
    
    def calculate_quality_score(self) -> float:
        """è®¡ç®—è§„å¾‹è´¨é‡ç»¼åˆå¾—åˆ†"""
        base_score = self.confidence * 0.4
        support_score = self.get_support_ratio() * 0.3
        validation_score = self.get_success_rate() * 0.2
        generalization_score = min(self.generalization_score, 1.0) * 0.1
        
        return base_score + support_score + validation_score + generalization_score


class AttributeExtractor:
    """å±æ€§æå–å™¨"""
    
    def __init__(self):
        # é¢„å®šä¹‰çš„å±æ€§æ˜ å°„
        self.environment_attributes = {
            SymbolicEnvironment.FOREST: ["æ¤è¢«èŒ‚å¯†åŒºåŸŸ", "é‡ç”ŸåŠ¨ç‰©æ –æ¯åœ°", "éšè”½ç¯å¢ƒ"],
            SymbolicEnvironment.OPEN_FIELD: ["å¼€é˜”åœ°å¸¦", "è§†é‡è‰¯å¥½åŒºåŸŸ", "æš´éœ²ç¯å¢ƒ"],
            SymbolicEnvironment.WATER_AREA: ["æ°´æºåŒºåŸŸ", "æ¹¿æ¶¦ç¯å¢ƒ", "è¡¥ç»™ç‚¹"],
            SymbolicEnvironment.DANGEROUS_ZONE: ["é«˜å±åŒºåŸŸ", "å¨èƒå¯†é›†åŒº", "è­¦æˆ’åŒºåŸŸ"],
            SymbolicEnvironment.SAFE_ZONE: ["å®‰å…¨åŒºåŸŸ", "åº‡æŠ¤æ‰€", "ä½å¨èƒåŒº"],
            SymbolicEnvironment.RESOURCE_RICH: ["èµ„æºä¸°å¯ŒåŒº", "è¡¥ç»™å……è¶³åŒº", "æ”¶è·åŒº"],
            SymbolicEnvironment.RESOURCE_SPARSE: ["èµ„æºç¨€å°‘åŒº", "è´«ç˜ åŒºåŸŸ", "ç”Ÿå­˜å›°éš¾åŒº"]
        }
        
        self.object_attributes = {
            SymbolicObjectCategory.DANGEROUS_ANIMAL: ["å¤§å‹åŠ¨ç‰©", "è‚‰é£ŸåŠ¨ç‰©", "æ”»å‡»æ€§åŠ¨ç‰©", "å¨èƒç”Ÿç‰©"],
            SymbolicObjectCategory.HARMLESS_ANIMAL: ["å°å‹åŠ¨ç‰©", "è‰é£ŸåŠ¨ç‰©", "æ¸©å’ŒåŠ¨ç‰©", "æ— å®³ç”Ÿç‰©"],
            SymbolicObjectCategory.EDIBLE_PLANT: ["é£Ÿç‰©æ¥æº", "è¥å…»æä¾›è€…", "å¯é‡‡é›†èµ„æº", "æ¤ç‰©ç±»é£Ÿç‰©"],
            SymbolicObjectCategory.POISONOUS_PLANT: ["æœ‰æ¯’æ¤ç‰©", "å±é™©æ¤ç‰©", "ä¸å¯é£Ÿç”¨æ¤ç‰©", "æœ‰å®³èµ„æº"],
            SymbolicObjectCategory.WATER_SOURCE: ["æ¶²ä½“èµ„æº", "ç”Ÿå­˜å¿…éœ€å“", "è¡¥ç»™æ¥æº", "æ°´åˆ†æä¾›è€…"],
            SymbolicObjectCategory.FELLOW_PLAYER: ["åŒç±»æ™ºèƒ½ä½“", "åˆä½œå¯¹è±¡", "ç¤¾äº¤ç›®æ ‡", "å‹æ–¹å•ä½"],
            SymbolicObjectCategory.OTHER_PLAYER: ["å¼‚ç±»æ™ºèƒ½ä½“", "ç«äº‰å¯¹è±¡", "è§‚å¯Ÿç›®æ ‡", "æœªçŸ¥æ„å›¾å•ä½"]
        }
        
        self.action_attributes = {
            SymbolicAction.MOVE: ["ä½ç½®å˜åŒ–", "ç©ºé—´è¡Œä¸º", "åŸºç¡€è¡ŒåŠ¨"],
            SymbolicAction.ATTACK: ["æ”»å‡»æ€§è¡Œä¸º", "ä¸»åŠ¨è¡ŒåŠ¨", "é«˜é£é™©è¡Œä¸º"],
            SymbolicAction.AVOID: ["é˜²å¾¡æ€§è¡Œä¸º", "è¢«åŠ¨è¡ŒåŠ¨", "å®‰å…¨è¡Œä¸º"],
            SymbolicAction.EAT: ["æ¶ˆè€—è¡Œä¸º", "è¥å…»è·å–", "èµ„æºåˆ©ç”¨"],
            SymbolicAction.DRINK: ["è¡¥ç»™è¡Œä¸º", "æ°´åˆ†è·å–", "ç”Ÿå­˜è¡Œä¸º"],
            SymbolicAction.GATHER: ["æ”¶é›†è¡Œä¸º", "èµ„æºè·å–", "é‡‡é›†è¡Œä¸º"],
            SymbolicAction.EXPLORE: ["æ¢ç´¢è¡Œä¸º", "ä¿¡æ¯è·å–", "ä¸»åŠ¨è¡Œä¸º"],
            SymbolicAction.INTERACT: ["ç¤¾äº¤è¡Œä¸º", "äº¤æµè¡Œä¸º", "äº’åŠ¨è¡Œä¸º"],
            SymbolicAction.REST: ["æ¢å¤è¡Œä¸º", "è¢«åŠ¨è¡Œä¸º", "ç»´æŠ¤è¡Œä¸º"]
        }
        
        # æ·»åŠ å·¥å…·å±æ€§æ˜ å°„
        self.tool_attributes = {
            SymbolicTool.NONE: ["æ— å·¥å…·", "å¾’æ‰‹", "è‡ªç„¶èƒ½åŠ›"],
            SymbolicTool.STONE: ["çŸ³åˆ¶å·¥å…·", "ç¡¬è´¨å·¥å…·", "åŸå§‹å·¥å…·", "æŠ•æ·æ­¦å™¨"],
            SymbolicTool.STICK: ["æœ¨åˆ¶å·¥å…·", "æ£æ£’", "å»¶ä¼¸å·¥å…·", "è¿‘æˆ˜æ­¦å™¨"],
            SymbolicTool.SPEAR: ["é•¿çŸ›å·¥å…·", "å°–é”å·¥å…·", "è¿œç¨‹æ­¦å™¨", "ç‹©çŒå·¥å…·"],
            SymbolicTool.BOW: ["å¼“ç®­å·¥å…·", "è¿œç¨‹å·¥å…·", "ç²¾å‡†æ­¦å™¨", "ç‹©çŒè£…å¤‡"],
            SymbolicTool.BASKET: ["å®¹å™¨å·¥å…·", "å­˜å‚¨å·¥å…·", "æ”¶é›†å·¥å…·", "æºå¸¦è£…ç½®"],
            SymbolicTool.SHOVEL: ["æŒ–æ˜å·¥å…·", "åœŸå·¥å·¥å…·", "å»ºé€ å·¥å…·", "åŠ³åŠ¨è£…å¤‡"]
        }
        
        # ğŸ”§ æ·»åŠ å·¥å…·åç§°æ˜ å°„ï¼šä¸­æ–‡åç§°/ç±»å‹ -> æšä¸¾å·¥å…·
        self.tool_name_mapping = {
            # ä¸­æ–‡å·¥å…·åç§°æ˜ å°„
            "å¼“ç®­": SymbolicTool.BOW,
            "é•¿çŸ›": SymbolicTool.SPEAR, 
            "çŸ³å¤´": SymbolicTool.STONE,
            "ç¯®å­": SymbolicTool.BASKET,
            "é“é”¹": SymbolicTool.SHOVEL,
            "æ£å­": SymbolicTool.STICK,
            "é”¤å­": SymbolicTool.STICK,  # é”¤å­å½’ç±»ä¸ºæ£æ£’ç±»
            
            # è‹±æ–‡å·¥å…·åç§°æ˜ å°„
            "bow": SymbolicTool.BOW,
            "spear": SymbolicTool.SPEAR,
            "stone": SymbolicTool.STONE, 
            "basket": SymbolicTool.BASKET,
            "shovel": SymbolicTool.SHOVEL,
            "stick": SymbolicTool.STICK,
            
            # å·¥å…·ç±»å‹æ˜ å°„ï¼ˆæ¥è‡ªç»éªŒè®°å½•ï¼‰
            "ranged_weapon": SymbolicTool.BOW,      # è¿œç¨‹æ­¦å™¨ -> å¼“ç®­
            "weapon": SymbolicTool.SPEAR,           # æ­¦å™¨ -> é•¿çŸ›  
            "digging_tool": SymbolicTool.SHOVEL,    # æŒ–æ˜å·¥å…· -> é“é”¹
            "melee_weapon": SymbolicTool.STICK,     # è¿‘æˆ˜æ­¦å™¨ -> æ£å­
            "projectile": SymbolicTool.STONE,       # æŠ•æ·ç‰© -> çŸ³å¤´
            "container": SymbolicTool.BASKET,       # å®¹å™¨ -> ç¯®å­
            
            # å¤„ç†Noneæƒ…å†µ
            "none": SymbolicTool.NONE,
            "æ— ": SymbolicTool.NONE,
            "": SymbolicTool.NONE
        }
    
    def extract_environment_attributes(self, env) -> List[str]:
        """æå–ç¯å¢ƒå±æ€§"""
        if env is None:
            return []
        
        # ä½¿ç”¨ç¯å¢ƒå†…å®¹ä½œä¸ºé”®
        env_content = getattr(env, 'content', str(env))
        return self.environment_attributes.get(env_content, [])
    
    def extract_object_attributes(self, obj, characteristics) -> List[str]:
        """æå–å¯¹è±¡å±æ€§"""
        attributes = []
        
        if obj is not None:
            # ä½¿ç”¨å¯¹è±¡å†…å®¹ä½œä¸ºé”®
            obj_content = getattr(obj, 'content', str(obj))
            attributes = self.object_attributes.get(obj_content, []).copy()
        
        # åŸºäºç‰¹å¾æ·»åŠ åŠ¨æ€å±æ€§
        if characteristics is not None:
            if getattr(characteristics, 'dangerous', False):
                attributes.extend(["å±é™©å®ä½“", "å¨èƒæº"])
            if getattr(characteristics, 'edible', False):
                attributes.extend(["å¯é£Ÿç”¨å®ä½“", "è¥å…»æº"])
            
            size = getattr(characteristics, 'size', None)
            if size == "large":
                attributes.extend(["å¤§å‹å®ä½“", "æ˜¾è‘—ç›®æ ‡"])
            elif size == "small":
                attributes.extend(["å°å‹å®ä½“", "å¾®å°ç›®æ ‡"])
        
        return list(set(attributes))  # å»é‡
    
    def extract_action_attributes(self, action) -> List[str]:
        """æå–åŠ¨ä½œå±æ€§"""
        if action is None:
            return []
        
        # ä½¿ç”¨åŠ¨ä½œå†…å®¹ä½œä¸ºé”®
        action_content = getattr(action, 'content', str(action))
        return self.action_attributes.get(action_content, [])
    
    def extract_tool_attributes(self, tool) -> List[str]:
        """æå–å·¥å…·å±æ€§ - ä¿®å¤ç‰ˆæœ¬"""
        if tool is None:
            return ["æ— å·¥å…·", "å¾’æ‰‹", "è‡ªç„¶èƒ½åŠ›"]
        
        # è·å–å·¥å…·å†…å®¹ï¼ˆå¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡ï¼‰
        tool_content = getattr(tool, 'content', str(tool))
        
        # ğŸ”§ ç¬¬ä¸€æ­¥ï¼šå°è¯•ç›´æ¥ä»å·¥å…·åç§°æ˜ å°„ä¸­æŸ¥æ‰¾
        if tool_content in self.tool_name_mapping:
            mapped_tool_enum = self.tool_name_mapping[tool_content]
            attributes = self.tool_attributes.get(mapped_tool_enum, [])
            if attributes:  # å¦‚æœæ‰¾åˆ°å±æ€§ï¼Œç›´æ¥è¿”å›
                return attributes.copy()
        
        # ğŸ”§ ç¬¬äºŒæ­¥ï¼šå°è¯•æŒ‰å·¥å…·åç§°çš„å°å†™å½¢å¼æŸ¥æ‰¾
        tool_content_lower = tool_content.lower()
        if tool_content_lower in self.tool_name_mapping:
            mapped_tool_enum = self.tool_name_mapping[tool_content_lower]
            attributes = self.tool_attributes.get(mapped_tool_enum, [])
            if attributes:
                return attributes.copy()
        
        # ğŸ”§ ç¬¬ä¸‰æ­¥ï¼šæ¨¡ç³ŠåŒ¹é…ï¼ˆåŒ…å«å…³ç³»ï¼‰
        for name_key, tool_enum in self.tool_name_mapping.items():
            if name_key and tool_content and (name_key in tool_content or tool_content in name_key):
                attributes = self.tool_attributes.get(tool_enum, [])
                if attributes:
                    return attributes.copy()
        
        # ğŸ”§ ç¬¬å››æ­¥ï¼šå¦‚æœä»¥ä¸Šéƒ½å¤±è´¥ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨å·¥å…·æšä¸¾ç±»å‹ä½œä¸ºé”®ï¼ˆå‘ä¸‹å…¼å®¹ï¼‰
        if hasattr(tool, '__class__') and hasattr(tool.__class__, '__name__'):
            for tool_enum in self.tool_attributes.keys():
                if hasattr(tool_enum, 'name') and tool_enum.name.lower() in tool_content.lower():
                    return self.tool_attributes[tool_enum].copy()
        
        # ğŸ”§ ç¬¬äº”æ­¥ï¼šå¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œè¿”å›é€šç”¨å·¥å…·å±æ€§
        return ["æœªçŸ¥å·¥å…·", "å·¥å…·ç±»ç‰©å“", "è¾…åŠ©è£…å¤‡"]
    
    def extract_characteristics_attributes(self, characteristics) -> List[str]:
        """æå–ç‰¹å¾å±æ€§"""
        attributes = []
        
        if characteristics is None:
            return attributes
        
        # ç‰©ç†ç‰¹å¾
        size = getattr(characteristics, 'size', None)
        if size:
            attributes.append(f"{size}å‹å®ä½“")
        
        if getattr(characteristics, 'dangerous', False):
            attributes.append("å±é™©ç‰¹å¾")
        if getattr(characteristics, 'edible', False):
            attributes.append("å¯é£Ÿç”¨ç‰¹å¾")
        
        # è·ç¦»ç‰¹å¾
        distance = getattr(characteristics, 'distance', 0)
        if distance > 0:
            if distance < 2:
                attributes.append("è¿‘è·ç¦»")
            elif distance < 5:
                attributes.append("ä¸­è·ç¦»")
            else:
                attributes.append("è¿œè·ç¦»")
        
        # å¯è§æ€§
        visibility = getattr(characteristics, 'visibility', None)
        if visibility == "hidden":
            attributes.append("éšè”½ç‰¹å¾")
        elif visibility == "visible":
            attributes.append("å¯è§ç‰¹å¾")
        
        return attributes


class EOCARCombinationGenerator:
    """EOCARç»„åˆç”Ÿæˆå™¨ä¸»ç±»"""
    
    def __init__(self, logger=None):
        self.logger = logger
        self.attribute_extractor = AttributeExtractor()
        self.generated_rules: List[CandidateRule] = []
        self.rule_counter = 0
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.generation_stats = {
            'total_rules_generated': 0,
            'rules_by_combination_type': defaultdict(int),
            'rules_by_abstraction_level': defaultdict(int),
            'generation_time_ms': 0.0
        }
    
    def generate_candidate_rules(self, eocar_experiences: List[EOCATR_Tuple]) -> List[CandidateRule]:
        """
        ä»EOCATRç»éªŒåˆ—è¡¨ç”Ÿæˆå€™é€‰è§„å¾‹
        
        Args:
            eocar_experiences: EOCATRç»éªŒåˆ—è¡¨
            
        Returns:
            List[CandidateRule]: ç”Ÿæˆçš„å€™é€‰è§„å¾‹åˆ—è¡¨
        """
        start_time = time.time()
        
        if not eocar_experiences:
            return []
        
        all_candidate_rules = []
        
        # ğŸ”§ ä¼˜å…ˆå¤„ç†å·¥å…·ä½¿ç”¨ç»éªŒï¼Œå¢å¼ºå·¥å…·è§„å¾‹æƒé‡
        tool_experiences = []
        non_tool_experiences = []
        
        for experience in eocar_experiences:
            if self._is_tool_usage_experience(experience):
                tool_experiences.append(experience)
            else:
                non_tool_experiences.append(experience)
        
        # ğŸ”§ å…ˆå¤„ç†å·¥å…·ç»éªŒï¼Œç»™äºˆä¼˜å…ˆçº§
        for experience in tool_experiences:
            experience_rules = self._generate_rules_from_single_experience(experience)
            # ğŸ”§ ä¸ºå·¥å…·ç»éªŒç”Ÿæˆçš„æ‰€æœ‰è§„å¾‹å¢åŠ é¢å¤–æƒé‡
            for rule in experience_rules:
                rule.confidence += 0.15  # å·¥å…·ç»éªŒé¢å¤–ç½®ä¿¡åº¦åŠ æˆ
                rule.generalization_score += 0.25  # é¢å¤–æ³›åŒ–å¾—åˆ†åŠ æˆ
            all_candidate_rules.extend(experience_rules)
            
        # ç„¶åå¤„ç†éå·¥å…·ç»éªŒ
        for experience in non_tool_experiences:
            experience_rules = self._generate_rules_from_single_experience(experience)
            all_candidate_rules.extend(experience_rules)
        
        # å»é‡å’Œè´¨é‡è¿‡æ»¤
        filtered_rules = self._filter_and_deduplicate_rules(all_candidate_rules)
        
        # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        generation_time = (time.time() - start_time) * 1000
        self.generation_stats['generation_time_ms'] = generation_time
        self.generation_stats['total_rules_generated'] += len(filtered_rules)
        
        if self.logger:
            # ğŸ”§ ç»Ÿè®¡å·¥å…·ç›¸å…³è§„å¾‹çš„æ•°é‡
            tool_rules_count = sum(1 for rule in filtered_rules 
                                 if any(tool_type in rule.combination_type.value 
                                       for tool_type in ['tool']))
            
            self.logger.log(f"ä»{len(eocar_experiences)}ä¸ªEOCATRç»éªŒç”Ÿæˆäº†{len(filtered_rules)}ä¸ªå€™é€‰è§„å¾‹")
            self.logger.log(f"å…¶ä¸­å·¥å…·ç›¸å…³è§„å¾‹: {tool_rules_count}ä¸ªï¼Œå·¥å…·ç»éªŒ: {len(tool_experiences)}ä¸ª")
            self.logger.log(f"ğŸ”§ å·¥å…·è§„å¾‹æƒé‡å¢å¼º: ç½®ä¿¡åº¦+0.25, æ³›åŒ–å¾—åˆ†+0.45")
        
        return filtered_rules
    
    def _is_tool_usage_experience(self, experience: EOCATR_Tuple) -> bool:
        """æ£€æŸ¥ç»éªŒæ˜¯å¦ä¸ºå·¥å…·ä½¿ç”¨ç»éªŒ"""
        # æ£€æŸ¥å·¥å…·å…ƒç´ æ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºç©º
        if hasattr(experience, 'tool') and experience.tool:
            # æ£€æŸ¥å·¥å…·å†…å®¹æ˜¯å¦æœ‰æ•ˆï¼ˆä¸æ˜¯"none"æˆ–ç©ºå­—ç¬¦ä¸²ï¼‰
            if hasattr(experience.tool, 'content'):
                tool_content = experience.tool.content.lower()
                return tool_content not in ['none', '', 'null', 'unknown']
            # æ£€æŸ¥å·¥å…·åç§°
            elif hasattr(experience.tool, 'name'):
                tool_name = experience.tool.name.lower()
                return tool_name not in ['none', '', 'null', 'unknown']
        
        # æ£€æŸ¥æ˜¯å¦è°ƒç”¨äº†is_tool_usageæ–¹æ³•
        if hasattr(experience, 'is_tool_usage') and callable(experience.is_tool_usage):
            return experience.is_tool_usage()
            
        # æ£€æŸ¥ç»éªŒä¸­æ˜¯å¦æœ‰å·¥å…·ç›¸å…³çš„æ ‡è®°
        if hasattr(experience, '_metadata') and experience._metadata:
            return experience._metadata.get('tool_usage', False)
            
        return False
    
    def _generate_rules_from_single_experience(self, experience: EOCATR_Tuple) -> List[CandidateRule]:
        """ä»å•ä¸ªEOCATRç»éªŒç”Ÿæˆå€™é€‰è§„å¾‹"""
        rules = []
        
        # æå–å±æ€§
        env_attrs = self.attribute_extractor.extract_environment_attributes(experience.environment)
        obj_attrs = self.attribute_extractor.extract_object_attributes(
            experience.object_category, experience.characteristics
        )
        action_attrs = self.attribute_extractor.extract_action_attributes(experience.action)
        char_attrs = self.attribute_extractor.extract_characteristics_attributes(experience.characteristics)
        tool_attrs = self.attribute_extractor.extract_tool_attributes(experience.tool)
        
        # ğŸ”§ ç”Ÿæˆç¬¦åˆçº¦æŸçš„ç»„åˆç±»å‹è§„å¾‹ï¼ˆæ’é™¤è¿åCâ‚‚/Câ‚ƒçº¦æŸçš„ä¸¤å…ƒè§„å¾‹ï¼‰
        forbidden_types = {CombinationType.E_R, CombinationType.O_R, CombinationType.C_R, 
                          CombinationType.A_R, CombinationType.T_R}
        
        # ğŸ”§ å®šä¹‰å·¥å…·ç›¸å…³çš„ç»„åˆç±»å‹ï¼ˆä¼˜å…ˆå¤„ç†ï¼‰
        tool_related_types = {
            CombinationType.E_T_R, CombinationType.O_T_R, CombinationType.C_T_R, CombinationType.A_T_R,  # åŒå…ƒç´ +å·¥å…·
            CombinationType.E_O_T_R, CombinationType.E_C_T_R, CombinationType.E_A_T_R,  # ä¸‰å…ƒç´ +å·¥å…·
            CombinationType.O_C_T_R, CombinationType.O_A_T_R, CombinationType.C_A_T_R,
            CombinationType.E_O_C_T_R, CombinationType.E_O_A_T_R, CombinationType.E_C_A_T_R,  # å››å…ƒç´ +å·¥å…·
            CombinationType.O_C_A_T_R, CombinationType.E_O_C_A_T_R  # å…¨å…ƒç´ 
        }
        
        # ğŸ”§ ä¼˜å…ˆç”Ÿæˆå·¥å…·ç›¸å…³è§„å¾‹
        for combination_type in tool_related_types:
            if combination_type in forbidden_types:
                continue
            combination_rules = self._generate_combination_rules(
                combination_type, experience, env_attrs, obj_attrs, action_attrs, char_attrs, tool_attrs
            )
            # ğŸ”§ ä¸ºå·¥å…·ç›¸å…³è§„å¾‹å¢åŠ æƒé‡åŠ æˆ
            for rule in combination_rules:
                rule.confidence += 0.1  # å·¥å…·è§„å¾‹åˆå§‹ç½®ä¿¡åº¦åŠ æˆ
                rule.generalization_score += 0.2  # æ³›åŒ–å¾—åˆ†åŠ æˆ
            rules.extend(combination_rules)
        
        # ğŸ”§ ç„¶åç”Ÿæˆå…¶ä»–ç¬¦åˆçº¦æŸçš„è§„å¾‹
        for combination_type in CombinationType:
            # è·³è¿‡è¿åçº¦æŸçš„ä¸¤å…ƒè§„å¾‹ç±»å‹å’Œå·²å¤„ç†çš„å·¥å…·ç›¸å…³ç±»å‹
            if combination_type in forbidden_types or combination_type in tool_related_types:
                continue
                
            combination_rules = self._generate_combination_rules(
                combination_type, experience, env_attrs, obj_attrs, action_attrs, char_attrs, tool_attrs
            )
            rules.extend(combination_rules)
        
        return rules
    
    def _generate_combination_rules(self, combination_type: CombinationType, experience: EOCATR_Tuple,
                                  env_attrs: List[str], obj_attrs: List[str], 
                                  action_attrs: List[str], char_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ä¸ºç‰¹å®šç»„åˆç±»å‹ç”Ÿæˆè§„å¾‹"""
        rules = []
        
        # ğŸ”§ ç¦æ­¢ç”Ÿæˆè¿åCâ‚‚/Câ‚ƒçº¦æŸçš„ä¸¤å…ƒè§„å¾‹
        # Câ‚‚çº¦æŸï¼šè‡³å°‘ä¸€ä¸ªå¯æ§å› å­ï¼ˆAæˆ–Tï¼‰
        # Câ‚ƒçº¦æŸï¼šè‡³å°‘ä¸€ä¸ªä¸Šä¸‹æ–‡å› å­ï¼ˆEã€Oã€Cï¼‰
        # ä¸¤å…ƒè§„å¾‹E-Rã€O-Rã€C-Rã€A-Rã€T-Réƒ½è¿åäº†å…¶ä¸­ä¸€ä¸ªçº¦æŸï¼Œå› æ­¤è¢«ç¦æ­¢
        
        # æ³¨é‡Šæ‰è¿åçº¦æŸçš„ä¸¤å…ƒè§„å¾‹ç”Ÿæˆ
        # if combination_type == CombinationType.E_R:
        #     rules.extend(self._generate_e_r_rules(experience, env_attrs))  # è¿åCâ‚‚çº¦æŸ
        # elif combination_type == CombinationType.O_R:
        #     rules.extend(self._generate_o_r_rules(experience, obj_attrs))  # è¿åCâ‚‚çº¦æŸ
        # elif combination_type == CombinationType.C_R:
        #     rules.extend(self._generate_c_r_rules(experience, char_attrs))  # è¿åCâ‚‚çº¦æŸ
        # elif combination_type == CombinationType.A_R:
        #     rules.extend(self._generate_a_r_rules(experience, action_attrs))  # è¿åCâ‚ƒçº¦æŸ
        # elif combination_type == CombinationType.T_R:
        #     rules.extend(self._generate_t_r_rules(experience, tool_attrs))  # è¿åCâ‚ƒçº¦æŸ
        
        # ğŸ”§ å•å…ƒç´ +ç»“æœè§„å¾‹è¢«å®Œå…¨ç¦æ­¢ï¼Œè·³è¿‡å¤„ç†
        if combination_type in [CombinationType.E_R, CombinationType.O_R, CombinationType.C_R, 
                               CombinationType.A_R, CombinationType.T_R]:
            if hasattr(self, 'logger') and self.logger:
                self.logger.log(f"ğŸš« ç¦æ­¢ç”Ÿæˆä¸¤å…ƒè§„å¾‹: {combination_type} (è¿åCâ‚‚/Câ‚ƒçº¦æŸ)")
            return rules  # è¿”å›ç©ºåˆ—è¡¨
        
        # åŒå…ƒç´ +ç»“æœ (10ç§)
        elif combination_type == CombinationType.E_O_R:
            rules.extend(self._generate_e_o_r_rules(experience, env_attrs, obj_attrs))
        elif combination_type == CombinationType.E_C_R:
            rules.extend(self._generate_e_c_r_rules(experience, env_attrs, char_attrs))
        elif combination_type == CombinationType.E_A_R:
            rules.extend(self._generate_e_a_r_rules(experience, env_attrs, action_attrs))
        elif combination_type == CombinationType.E_T_R:
            rules.extend(self._generate_e_t_r_rules(experience, env_attrs, tool_attrs))
        elif combination_type == CombinationType.O_C_R:
            rules.extend(self._generate_o_c_r_rules(experience, obj_attrs, char_attrs))
        elif combination_type == CombinationType.O_A_R:
            rules.extend(self._generate_o_a_r_rules(experience, obj_attrs, action_attrs))
        elif combination_type == CombinationType.O_T_R:
            rules.extend(self._generate_o_t_r_rules(experience, obj_attrs, tool_attrs))
        elif combination_type == CombinationType.C_A_R:
            rules.extend(self._generate_c_a_r_rules(experience, char_attrs, action_attrs))
        elif combination_type == CombinationType.C_T_R:
            rules.extend(self._generate_c_t_r_rules(experience, char_attrs, tool_attrs))
        elif combination_type == CombinationType.A_T_R:
            rules.extend(self._generate_a_t_r_rules(experience, action_attrs, tool_attrs))
        
        # ä¸‰å…ƒç´ +ç»“æœ (10ç§)
        elif combination_type == CombinationType.E_O_C_R:
            rules.extend(self._generate_e_o_c_r_rules(experience, env_attrs, obj_attrs, char_attrs))
        elif combination_type == CombinationType.E_O_A_R:
            rules.extend(self._generate_e_o_a_r_rules(experience, env_attrs, obj_attrs, action_attrs))
        elif combination_type == CombinationType.E_O_T_R:
            rules.extend(self._generate_e_o_t_r_rules(experience, env_attrs, obj_attrs, tool_attrs))
        elif combination_type == CombinationType.E_C_A_R:
            rules.extend(self._generate_e_c_a_r_rules(experience, env_attrs, char_attrs, action_attrs))
        elif combination_type == CombinationType.E_C_T_R:
            rules.extend(self._generate_e_c_t_r_rules(experience, env_attrs, char_attrs, tool_attrs))
        elif combination_type == CombinationType.E_A_T_R:
            rules.extend(self._generate_e_a_t_r_rules(experience, env_attrs, action_attrs, tool_attrs))
        elif combination_type == CombinationType.O_C_A_R:
            rules.extend(self._generate_o_c_a_r_rules(experience, obj_attrs, char_attrs, action_attrs))
        elif combination_type == CombinationType.O_C_T_R:
            rules.extend(self._generate_o_c_t_r_rules(experience, obj_attrs, char_attrs, tool_attrs))
        elif combination_type == CombinationType.O_A_T_R:
            rules.extend(self._generate_o_a_t_r_rules(experience, obj_attrs, action_attrs, tool_attrs))
        elif combination_type == CombinationType.C_A_T_R:
            rules.extend(self._generate_c_a_t_r_rules(experience, char_attrs, action_attrs, tool_attrs))
        
        # å››å…ƒç´ +ç»“æœ (5ç§)
        elif combination_type == CombinationType.E_O_C_A_R:
            rules.extend(self._generate_e_o_c_a_r_rules(experience, env_attrs, obj_attrs, char_attrs, action_attrs))
        elif combination_type == CombinationType.E_O_C_T_R:
            rules.extend(self._generate_e_o_c_t_r_rules(experience, env_attrs, obj_attrs, char_attrs, tool_attrs))
        elif combination_type == CombinationType.E_O_A_T_R:
            rules.extend(self._generate_e_o_a_t_r_rules(experience, env_attrs, obj_attrs, action_attrs, tool_attrs))
        elif combination_type == CombinationType.E_C_A_T_R:
            rules.extend(self._generate_e_c_a_t_r_rules(experience, env_attrs, char_attrs, action_attrs, tool_attrs))
        elif combination_type == CombinationType.O_C_A_T_R:
            rules.extend(self._generate_o_c_a_t_r_rules(experience, obj_attrs, char_attrs, action_attrs, tool_attrs))
        
        # å…¨å…ƒç´ +ç»“æœ (1ç§)
        elif combination_type == CombinationType.E_O_C_A_T_R:
            rules.extend(self._generate_full_eocatr_rules(experience, env_attrs, obj_attrs, char_attrs, action_attrs, tool_attrs))
        
        # æ›´æ–°ç»Ÿè®¡
        self.generation_stats['rules_by_combination_type'][combination_type.value] += len(rules)
        
        return rules
    
    def _generate_e_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # æ£€æŸ¥ç¯å¢ƒæ˜¯å¦å­˜åœ¨
        if experience.environment is None:
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå…·ä½“ç¯å¢ƒ->ç»“æœ
        rule = self._create_candidate_rule(
            CombinationType.E_R,
            [f"ç¯å¢ƒ={experience.environment.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # å±æ€§æ³›åŒ–è§„å¾‹
        for env_attr in env_attrs:
            rule = self._create_candidate_rule(
                CombinationType.E_R,
                [f"ç¯å¢ƒå±æ€§={env_attr}"],
                f"åœ¨{env_attr}ä¸­",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_o_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # æ£€æŸ¥å¯¹è±¡æ˜¯å¦å­˜åœ¨
        if experience.object is None:
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå…·ä½“å¯¹è±¡->ç»“æœ
        rule = self._create_candidate_rule(
            CombinationType.O_R,
            [f"å¯¹è±¡={experience.object.content}"],
            f"é‡åˆ°{experience.object.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # å±æ€§æ³›åŒ–è§„å¾‹
        for obj_attr in obj_attrs:
            rule = self._create_candidate_rule(
                CombinationType.O_R,
                [f"å¯¹è±¡å±æ€§={obj_attr}"],
                f"é‡åˆ°{obj_attr}",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_c_r_rules(self, experience: EOCATR_Tuple, char_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç‰¹å¾->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # åŸºäºç‰¹å¾å±æ€§ç”Ÿæˆè§„å¾‹
        for char_attr in char_attrs:
            rule = self._create_candidate_rule(
                CombinationType.C_R,
                [f"ç‰¹å¾={char_attr}"],
                f"é¢å¯¹{char_attr}æ—¶",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_a_r_rules(self, experience: EOCATR_Tuple, action_attrs: List[str]) -> List[CandidateRule]:
        """ç”ŸæˆåŠ¨ä½œ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # æ£€æŸ¥åŠ¨ä½œæ˜¯å¦å­˜åœ¨
        if experience.action is None:
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå…·ä½“åŠ¨ä½œ->ç»“æœ
        rule = self._create_candidate_rule(
            CombinationType.A_R,
            [f"åŠ¨ä½œ={experience.action.content}"],
            f"æ‰§è¡Œ{experience.action.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # å±æ€§æ³›åŒ–è§„å¾‹
        for action_attr in action_attrs:
            rule = self._create_candidate_rule(
                CombinationType.A_R,
                [f"åŠ¨ä½œå±æ€§={action_attr}"],
                f"æ‰§è¡Œ{action_attr}",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_t_r_rules(self, experience: EOCATR_Tuple, tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # æ£€æŸ¥å·¥å…·æ˜¯å¦å­˜åœ¨
        if experience.tool is None:
            # æ— å·¥å…·çš„æƒ…å†µ
            rule = self._create_candidate_rule(
                CombinationType.T_R,
                ["å·¥å…·=æ— å·¥å…·"],
                "ä¸ä½¿ç”¨å·¥å…·æ—¶",
                result_summary,
                experience,
                abstraction_level=0
            )
            rules.append(rule)
        else:
            # åŸºç¡€è§„å¾‹ï¼šå…·ä½“å·¥å…·->ç»“æœ
            rule = self._create_candidate_rule(
                CombinationType.T_R,
                [f"å·¥å…·={experience.tool.content}"],
                f"ä½¿ç”¨{experience.tool.content}å·¥å…·æ—¶",
                result_summary,
                experience,
                abstraction_level=0
            )
            rules.append(rule)
        
        # å±æ€§æ³›åŒ–è§„å¾‹
        for tool_attr in tool_attrs:
            rule = self._create_candidate_rule(
                CombinationType.T_R,
                [f"å·¥å…·å±æ€§={tool_attr}"],
                f"ä½¿ç”¨{tool_attr}æ—¶",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_e_t_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.environment is None or experience.tool is None:
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå…·ä½“ç¯å¢ƒ+å…·ä½“å·¥å…·->ç»“æœ
        rule = self._create_candidate_rule(
            CombinationType.E_T_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"å·¥å…·={experience.tool.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # ç¯å¢ƒå±æ€§+å…·ä½“å·¥å…·
        for env_attr in env_attrs:
            rule = self._create_candidate_rule(
                CombinationType.E_T_R,
                [f"ç¯å¢ƒå±æ€§={env_attr}", f"å·¥å…·={experience.tool.content}"],
                f"åœ¨{env_attr}ä¸­ä½¿ç”¨{experience.tool.content}å·¥å…·",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_o_t_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.object is None or experience.tool is None:
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå…·ä½“å¯¹è±¡+å…·ä½“å·¥å…·->ç»“æœ
        rule = self._create_candidate_rule(
            CombinationType.O_T_R,
            [f"å¯¹è±¡={experience.object.content}", f"å·¥å…·={experience.tool.content}"],
            f"å¯¹{experience.object.content}ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # å¯¹è±¡å±æ€§+å…·ä½“å·¥å…·
        for obj_attr in obj_attrs:
            rule = self._create_candidate_rule(
                CombinationType.O_T_R,
                [f"å¯¹è±¡å±æ€§={obj_attr}", f"å·¥å…·={experience.tool.content}"],
                f"å¯¹{obj_attr}ä½¿ç”¨{experience.tool.content}å·¥å…·",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_c_t_r_rules(self, experience: EOCATR_Tuple, char_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç‰¹å¾+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.tool is None:
            return rules
        
        # ç‰¹å¾å±æ€§+å…·ä½“å·¥å…·
        for char_attr in char_attrs:
            rule = self._create_candidate_rule(
                CombinationType.C_T_R,
                [f"ç‰¹å¾={char_attr}", f"å·¥å…·={experience.tool.content}"],
                f"é¢å¯¹{char_attr}æ—¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_a_t_r_rules(self, experience: EOCATR_Tuple, action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”ŸæˆåŠ¨ä½œ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.action is None or experience.tool is None:
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå…·ä½“åŠ¨ä½œ+å…·ä½“å·¥å…·->ç»“æœ
        rule = self._create_candidate_rule(
            CombinationType.A_T_R,
            [f"åŠ¨ä½œ={experience.action.content}", f"å·¥å…·={experience.tool.content}"],
            f"æ‰§è¡Œ{experience.action.content}è¡ŒåŠ¨å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_e_o_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], obj_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å¯¹è±¡->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # æ£€æŸ¥ç¯å¢ƒå’Œå¯¹è±¡æ˜¯å¦å­˜åœ¨
        if experience.environment is None or experience.object is None:
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_O_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"å¯¹è±¡={experience.object.content}"],
            f"åœ¨{experience.environment.content}é‡åˆ°{experience.object.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # ç¯å¢ƒæ³›åŒ–+å¯¹è±¡æ³›åŒ–ç»„åˆ
        for env_attr in env_attrs[:2]:  # é™åˆ¶ç»„åˆæ•°é‡
            for obj_attr in obj_attrs[:2]:
                rule = self._create_candidate_rule(
                    CombinationType.E_O_R,
                    [f"ç¯å¢ƒå±æ€§={env_attr}", f"å¯¹è±¡å±æ€§={obj_attr}"],
                    f"åœ¨{env_attr}é‡åˆ°{obj_attr}",
                    result_summary,
                    experience,
                    abstraction_level=2
                )
                rules.append(rule)
        
        return rules
    
    def _generate_e_c_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], char_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+ç‰¹å¾->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # ç¯å¢ƒ+ç‰¹å¾ç»„åˆ
        for env_attr in env_attrs[:2]:
            for char_attr in char_attrs[:2]:
                rule = self._create_candidate_rule(
                    CombinationType.E_C_R,
                    [f"ç¯å¢ƒå±æ€§={env_attr}", f"ç‰¹å¾={char_attr}"],
                    f"åœ¨{env_attr}é¢å¯¹{char_attr}",
                    result_summary,
                    experience,
                    abstraction_level=2
                )
                rules.append(rule)
        
        return rules
    
    def _generate_e_a_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+åŠ¨ä½œ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # æ£€æŸ¥ç¯å¢ƒå’ŒåŠ¨ä½œæ˜¯å¦å­˜åœ¨
        if experience.environment is None or experience.action is None:
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_A_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"åŠ¨ä½œ={experience.action.content}"],
            f"åœ¨{experience.environment.content}æ‰§è¡Œ{experience.action.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # å±æ€§æ³›åŒ–ç»„åˆ
        for env_attr in env_attrs[:2]:
            for action_attr in action_attrs[:2]:
                rule = self._create_candidate_rule(
                    CombinationType.E_A_R,
                    [f"ç¯å¢ƒå±æ€§={env_attr}", f"åŠ¨ä½œå±æ€§={action_attr}"],
                    f"åœ¨{env_attr}æ‰§è¡Œ{action_attr}",
                    result_summary,
                    experience,
                    abstraction_level=2
                )
                rules.append(rule)
        
        return rules
    
    def _generate_o_c_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str], char_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡+ç‰¹å¾->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # å¯¹è±¡+ç‰¹å¾ç»„åˆ
        for obj_attr in obj_attrs[:2]:
            for char_attr in char_attrs[:2]:
                rule = self._create_candidate_rule(
                    CombinationType.O_C_R,
                    [f"å¯¹è±¡å±æ€§={obj_attr}", f"ç‰¹å¾={char_attr}"],
                    f"é‡åˆ°{obj_attr}ä¸”å…·æœ‰{char_attr}",
                    result_summary,
                    experience,
                    abstraction_level=2
                )
                rules.append(rule)
        
        return rules
    
    def _generate_o_a_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str], action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡+åŠ¨ä½œ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # æ£€æŸ¥å¯¹è±¡å’ŒåŠ¨ä½œæ˜¯å¦å­˜åœ¨
        if experience.object is None or experience.action is None:
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.O_A_R,
            [f"å¯¹è±¡={experience.object.content}", f"åŠ¨ä½œ={experience.action.content}"],
            f"å¯¹{experience.object.content}æ‰§è¡Œ{experience.action.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # å±æ€§æ³›åŒ–ç»„åˆ
        for obj_attr in obj_attrs[:2]:
            for action_attr in action_attrs[:2]:
                rule = self._create_candidate_rule(
                    CombinationType.O_A_R,
                    [f"å¯¹è±¡å±æ€§={obj_attr}", f"åŠ¨ä½œå±æ€§={action_attr}"],
                    f"å¯¹{obj_attr}æ‰§è¡Œ{action_attr}",
                    result_summary,
                    experience,
                    abstraction_level=2
                )
                rules.append(rule)
        
        return rules
    
    def _generate_c_a_r_rules(self, experience: EOCATR_Tuple, char_attrs: List[str], action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç‰¹å¾+åŠ¨ä½œ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # ç‰¹å¾+åŠ¨ä½œç»„åˆ
        for char_attr in char_attrs[:2]:
            for action_attr in action_attrs[:2]:
                rule = self._create_candidate_rule(
                    CombinationType.C_A_R,
                    [f"ç‰¹å¾={char_attr}", f"åŠ¨ä½œå±æ€§={action_attr}"],
                    f"é¢å¯¹{char_attr}æ—¶æ‰§è¡Œ{action_attr}",
                    result_summary,
                    experience,
                    abstraction_level=2
                )
                rules.append(rule)
        
        return rules
    
    def _generate_e_o_c_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], 
                               obj_attrs: List[str], char_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å¯¹è±¡+ç‰¹å¾->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # åŸºç¡€ä¸‰å…ƒç»„è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_O_C_R,
            [f"ç¯å¢ƒ={experience.environment.content}", 
             f"å¯¹è±¡={experience.object.content}", 
             f"ç‰¹å¾=å…·ä½“ç‰¹å¾"],
            f"åœ¨{experience.environment.content}é‡åˆ°å…·æœ‰ç‰¹å®šç‰¹å¾çš„{experience.object.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # é™åˆ¶é«˜åº¦ç»„åˆä»¥æ§åˆ¶è§„å¾‹æ•°é‡
        if env_attrs and obj_attrs and char_attrs:
            rule = self._create_candidate_rule(
                CombinationType.E_O_C_R,
                [f"ç¯å¢ƒå±æ€§={env_attrs[0]}", 
                 f"å¯¹è±¡å±æ€§={obj_attrs[0]}", 
                 f"ç‰¹å¾={char_attrs[0]}"],
                f"åœ¨{env_attrs[0]}é‡åˆ°{char_attrs[0]}çš„{obj_attrs[0]}",
                result_summary,
                experience,
                abstraction_level=2
            )
            rules.append(rule)
        
        return rules
    
    def _generate_e_o_a_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], 
                               obj_attrs: List[str], action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å¯¹è±¡+åŠ¨ä½œ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # åŸºç¡€ä¸‰å…ƒç»„è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_O_A_R,
            [f"ç¯å¢ƒ={experience.environment.content}", 
             f"å¯¹è±¡={experience.object.content}", 
             f"åŠ¨ä½œ={experience.action.content}"],
            f"åœ¨{experience.environment.content}å¯¹{experience.object.content}æ‰§è¡Œ{experience.action.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_e_c_a_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], 
                               char_attrs: List[str], action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+ç‰¹å¾+åŠ¨ä½œ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # åŸºç¡€ä¸‰å…ƒç»„è§„å¾‹ï¼ˆæ€»æ˜¯ç”Ÿæˆï¼‰
        rule = self._create_candidate_rule(
            CombinationType.E_C_A_R,
            [f"ç¯å¢ƒ={experience.environment.content}", 
             f"ç‰¹å¾=å…·ä½“ç‰¹å¾", 
             f"åŠ¨ä½œ={experience.action.content}"],
            f"åœ¨{experience.environment.content}é¢å¯¹å…·ä½“ç‰¹å¾æ—¶æ‰§è¡Œ{experience.action.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        # é™åˆ¶ç»„åˆæ•°é‡çš„å±æ€§æ³›åŒ–è§„å¾‹
        if env_attrs and char_attrs and action_attrs:
            rule = self._create_candidate_rule(
                CombinationType.E_C_A_R,
                [f"ç¯å¢ƒå±æ€§={env_attrs[0]}", 
                 f"ç‰¹å¾={char_attrs[0]}", 
                 f"åŠ¨ä½œå±æ€§={action_attrs[0]}"],
                f"åœ¨{env_attrs[0]}é¢å¯¹{char_attrs[0]}æ—¶æ‰§è¡Œ{action_attrs[0]}",
                result_summary,
                experience,
                abstraction_level=2
            )
            rules.append(rule)
        
        return rules
    
    def _generate_o_c_a_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str], 
                               char_attrs: List[str], action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡+ç‰¹å¾+åŠ¨ä½œ->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # åŸºç¡€ä¸‰å…ƒç»„è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.O_C_A_R,
            [f"å¯¹è±¡={experience.object.content}", 
             f"ç‰¹å¾=å…·ä½“ç‰¹å¾", 
             f"åŠ¨ä½œ={experience.action.content}"],
            f"å¯¹å…·æœ‰ç‰¹å®šç‰¹å¾çš„{experience.object.content}æ‰§è¡Œ{experience.action.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_e_o_t_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], obj_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å¯¹è±¡+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.environment is None or experience.object is None or experience.tool is None:
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå…·ä½“ç¯å¢ƒ+å…·ä½“å¯¹è±¡+å…·ä½“å·¥å…·->ç»“æœ
        rule = self._create_candidate_rule(
            CombinationType.E_O_T_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"å¯¹è±¡={experience.object.content}", f"å·¥å…·={experience.tool.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­å¯¹{experience.object.content}ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_e_c_t_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], char_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+ç‰¹å¾+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.environment is None or experience.tool is None:
            return rules
        
        # é™åˆ¶ç»„åˆæ•°é‡
        if len(env_attrs) > 0 and len(char_attrs) > 0:
            rule = self._create_candidate_rule(
                CombinationType.E_C_T_R,
                [f"ç¯å¢ƒå±æ€§={env_attrs[0]}", f"ç‰¹å¾={char_attrs[0]}", f"å·¥å…·={experience.tool.content}"],
                f"åœ¨{env_attrs[0]}ä¸­é¢å¯¹{char_attrs[0]}æ—¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_e_a_t_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+åŠ¨ä½œ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.environment is None or experience.action is None or experience.tool is None:
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_A_T_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"åŠ¨ä½œ={experience.action.content}", f"å·¥å…·={experience.tool.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­æ‰§è¡Œ{experience.action.content}è¡ŒåŠ¨å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_o_c_t_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str], char_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡+ç‰¹å¾+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.object is None or experience.tool is None:
            return rules
        
        # é™åˆ¶ç»„åˆæ•°é‡
        if len(obj_attrs) > 0 and len(char_attrs) > 0:
            rule = self._create_candidate_rule(
                CombinationType.O_C_T_R,
                [f"å¯¹è±¡å±æ€§={obj_attrs[0]}", f"ç‰¹å¾={char_attrs[0]}", f"å·¥å…·={experience.tool.content}"],
                f"å¯¹{obj_attrs[0]}åœ¨{char_attrs[0]}æƒ…å†µä¸‹ä½¿ç”¨{experience.tool.content}å·¥å…·",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_o_a_t_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str], action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡+åŠ¨ä½œ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.object is None or experience.action is None or experience.tool is None:
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.O_A_T_R,
            [f"å¯¹è±¡={experience.object.content}", f"åŠ¨ä½œ={experience.action.content}", f"å·¥å…·={experience.tool.content}"],
            f"å¯¹{experience.object.content}æ‰§è¡Œ{experience.action.content}è¡ŒåŠ¨å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_c_a_t_r_rules(self, experience: EOCATR_Tuple, char_attrs: List[str], action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç‰¹å¾+åŠ¨ä½œ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if experience.action is None or experience.tool is None:
            return rules
        
        # é™åˆ¶ç»„åˆæ•°é‡
        if len(char_attrs) > 0 and len(action_attrs) > 0:
            rule = self._create_candidate_rule(
                CombinationType.C_A_T_R,
                [f"ç‰¹å¾={char_attrs[0]}", f"åŠ¨ä½œå±æ€§={action_attrs[0]}", f"å·¥å…·={experience.tool.content}"],
                f"é¢å¯¹{char_attrs[0]}æ—¶è¿›è¡Œ{action_attrs[0]}å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_e_o_c_a_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], obj_attrs: List[str], char_attrs: List[str], action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å¯¹è±¡+ç‰¹å¾+åŠ¨ä½œ->ç»“æœè§„å¾‹ï¼ˆé‡å‘½åçš„åŸfull_eocaræ–¹æ³•ï¼‰"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if (experience.environment is None or experience.object is None or 
            experience.action is None):
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_O_C_A_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"å¯¹è±¡={experience.object.content}", 
             f"åŠ¨ä½œ={experience.action.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­å¯¹{experience.object.content}æ‰§è¡Œ{experience.action.content}è¡ŒåŠ¨",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_e_o_c_t_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], obj_attrs: List[str], char_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å¯¹è±¡+ç‰¹å¾+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if (experience.environment is None or experience.object is None or 
            experience.tool is None):
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_O_C_T_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"å¯¹è±¡={experience.object.content}", 
             f"å·¥å…·={experience.tool.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­å¯¹{experience.object.content}ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_e_o_a_t_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], obj_attrs: List[str], action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+å¯¹è±¡+åŠ¨ä½œ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if (experience.environment is None or experience.object is None or 
            experience.action is None or experience.tool is None):
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_O_A_T_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"å¯¹è±¡={experience.object.content}", 
             f"åŠ¨ä½œ={experience.action.content}", f"å·¥å…·={experience.tool.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­å¯¹{experience.object.content}æ‰§è¡Œ{experience.action.content}è¡ŒåŠ¨å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_e_c_a_t_r_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], char_attrs: List[str], action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆç¯å¢ƒ+ç‰¹å¾+åŠ¨ä½œ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if (experience.environment is None or experience.action is None or 
            experience.tool is None):
            return rules
        
        # é™åˆ¶ç»„åˆæ•°é‡
        if len(env_attrs) > 0 and len(char_attrs) > 0 and len(action_attrs) > 0:
            rule = self._create_candidate_rule(
                CombinationType.E_C_A_T_R,
                [f"ç¯å¢ƒå±æ€§={env_attrs[0]}", f"ç‰¹å¾={char_attrs[0]}", 
                 f"åŠ¨ä½œå±æ€§={action_attrs[0]}", f"å·¥å…·={experience.tool.content}"],
                f"åœ¨{env_attrs[0]}ä¸­é¢å¯¹{char_attrs[0]}æ—¶è¿›è¡Œ{action_attrs[0]}å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
                result_summary,
                experience,
                abstraction_level=1
            )
            rules.append(rule)
        
        return rules
    
    def _generate_o_c_a_t_r_rules(self, experience: EOCATR_Tuple, obj_attrs: List[str], char_attrs: List[str], action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå¯¹è±¡+ç‰¹å¾+åŠ¨ä½œ+å·¥å…·->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if (experience.object is None or experience.action is None or 
            experience.tool is None):
            return rules
        
        # åŸºç¡€è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.O_C_A_T_R,
            [f"å¯¹è±¡={experience.object.content}", f"åŠ¨ä½œ={experience.action.content}", 
             f"å·¥å…·={experience.tool.content}"],
            f"å¯¹{experience.object.content}æ‰§è¡Œ{experience.action.content}è¡ŒåŠ¨å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_full_eocatr_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], obj_attrs: List[str], char_attrs: List[str], action_attrs: List[str], tool_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå®Œæ•´EOCATR->ç»“æœè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        if (experience.environment is None or experience.object is None or 
            experience.action is None or experience.tool is None):
            return rules
        
        # åŸºç¡€è§„å¾‹ï¼šå®Œæ•´EOCATR
        rule = self._create_candidate_rule(
            CombinationType.E_O_C_A_T_R,
            [f"ç¯å¢ƒ={experience.environment.content}", f"å¯¹è±¡={experience.object.content}", 
             f"åŠ¨ä½œ={experience.action.content}", f"å·¥å…·={experience.tool.content}"],
            f"åœ¨{experience.environment.content}ç¯å¢ƒä¸­å¯¹{experience.object.content}æ‰§è¡Œ{experience.action.content}è¡ŒåŠ¨å¹¶ä½¿ç”¨{experience.tool.content}å·¥å…·",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _generate_full_eocar_rules(self, experience: EOCATR_Tuple, env_attrs: List[str], 
                                  obj_attrs: List[str], char_attrs: List[str], 
                                  action_attrs: List[str]) -> List[CandidateRule]:
        """ç”Ÿæˆå®Œæ•´EOCARè§„å¾‹"""
        rules = []
        result_summary = self._summarize_result(experience.result)
        
        # å®Œæ•´çš„å…·ä½“è§„å¾‹
        rule = self._create_candidate_rule(
            CombinationType.E_O_C_A_R,
            [f"ç¯å¢ƒ={experience.environment.content}", 
             f"å¯¹è±¡={experience.object.content}", 
             f"ç‰¹å¾=å…·ä½“ç‰¹å¾", 
             f"åŠ¨ä½œ={experience.action.content}"],
            f"åœ¨{experience.environment.content}å¯¹å…·æœ‰ç‰¹å®šç‰¹å¾çš„{experience.object.content}æ‰§è¡Œ{experience.action.content}",
            result_summary,
            experience,
            abstraction_level=0
        )
        rules.append(rule)
        
        return rules
    
    def _create_candidate_rule(self, combination_type: CombinationType, condition_elements: List[str],
                              condition_text: str, expected_result: Dict[str, Any], 
                                                             source_experience: EOCATR_Tuple, abstraction_level: int = 0) -> CandidateRule:
        """åˆ›å»ºå€™é€‰è§„å¾‹"""
        self.rule_counter += 1
        
        # è®¡ç®—åˆå§‹ç½®ä¿¡åº¦ï¼ˆåŸºäºæŠ½è±¡å±‚æ¬¡ï¼‰
        base_confidence = 0.8 if abstraction_level == 0 else 0.6 if abstraction_level == 1 else 0.4
        
        # è®¡ç®—æ³›åŒ–å¾—åˆ†ï¼ˆæŠ½è±¡å±‚æ¬¡è¶Šé«˜ï¼Œæ³›åŒ–å¾—åˆ†è¶Šé«˜ï¼‰
        generalization_score = abstraction_level * 0.3
        
        rule = CandidateRule(
            rule_id=f"rule_{self.rule_counter}_{combination_type.value}",
            combination_type=combination_type,
            condition_elements=condition_elements,
            condition_text=condition_text,
            expected_result=expected_result,
            source_experiences=[source_experience.tuple_id],
            abstraction_level=abstraction_level,
            confidence=base_confidence,
            generalization_score=generalization_score
        )
        
        # æ›´æ–°ç»Ÿè®¡
        self.generation_stats['rules_by_abstraction_level'][abstraction_level] += 1
        
        return rule
    
    def _summarize_result(self, result) -> Dict[str, Any]:
        """æ€»ç»“ç»“æœä¿¡æ¯"""
        if result is None:
            return {'success': False, 'reward': 0.0, 'content': 'æ— ç»“æœ'}
        
        # å¯¹äºSymbolicElementç±»å‹çš„result
        if hasattr(result, 'content'):
            return {
                'success': hasattr(result, 'success') and result.success,
                'reward': getattr(result, 'reward', 0.0),
                'content': result.content,
                'tags': getattr(result, 'semantic_tags', [])
            }
        
        # å…¼å®¹æ—§çš„resultæ ¼å¼
        return {
            'success': getattr(result, 'success', False),
            'reward': getattr(result, 'reward', 0.0),
            'hp_change': getattr(result, 'hp_change', 0),
            'food_change': getattr(result, 'food_change', 0),
            'water_change': getattr(result, 'water_change', 0),
            'experience_gained': getattr(result, 'experience_gained', 0)
        }
    
    def _filter_and_deduplicate_rules(self, rules: List[CandidateRule]) -> List[CandidateRule]:
        """è¿‡æ»¤å’Œå»é‡è§„å¾‹"""
        if not rules:
            return []
        
        # æŒ‰æ¡ä»¶æ–‡æœ¬å»é‡
        seen_conditions = set()
        unique_rules = []
        
        for rule in rules:
            condition_key = f"{rule.combination_type.value}:{rule.condition_text}"
            if condition_key not in seen_conditions:
                seen_conditions.add(condition_key)
                unique_rules.append(rule)
        
        # æŒ‰è´¨é‡å¾—åˆ†æ’åºï¼Œä¿ç•™è´¨é‡è¾ƒé«˜çš„è§„å¾‹
        unique_rules.sort(key=lambda r: r.calculate_quality_score(), reverse=True)
        
        # é™åˆ¶æ•°é‡ä»¥æ§åˆ¶è®¡ç®—å¤æ‚åº¦
        max_rules = 50  # æ¯æ¬¡æœ€å¤šè¿”å›50ä¸ªè§„å¾‹
        return unique_rules[:max_rules]
    
    def get_statistics(self) -> Dict[str, Any]:
        """è·å–ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯"""
        return {
            'generation_stats': dict(self.generation_stats),
            'total_rules_in_memory': len(self.generated_rules),
            'rule_counter': self.rule_counter
        }


# æµ‹è¯•å‡½æ•°
def test_eocar_combination_generator():
    """æµ‹è¯•EOCATRç»„åˆç”Ÿæˆå™¨"""
    import sys
    import os
    
    # æ·»åŠ å½“å‰ç›®å½•åˆ°è·¯å¾„
    current_dir = os.path.dirname(os.path.abspath(__file__))
    if current_dir not in sys.path:
        sys.path.append(current_dir)
    
    print("=== EOCARç»„åˆç”Ÿæˆå™¨æµ‹è¯• ===")
    
    # åˆ›å»ºæµ‹è¯•æ—¥å¿—å™¨
    class TestLogger:
        def log(self, message):
            print(f"[LOG] {message}")
    
    # åˆ›å»ºç”Ÿæˆå™¨
    generator = EOCARCombinationGenerator(logger=TestLogger())
    
    # åˆ›å»ºæµ‹è¯•EOCATRç»éªŒ
    test_experience = EOCATR_Tuple(
        environment=SymbolicEnvironment.FOREST,
        object_category=SymbolicObjectCategory.DANGEROUS_ANIMAL,
        characteristics=SymbolicCharacteristics(
            distance=2.0,
            size="large",
            dangerous=True,
            activity_state="moving"
        ),
        action=SymbolicAction.AVOID,
        tool=SymbolicTool.NONE,  # æ·»åŠ å·¥å…·å­—æ®µ
        result=SymbolicResult(
            success=True,
            reward=0.5,
            hp_change=0,
            experience_gained=True
        ),
        timestamp=time.time(),
        confidence=0.9,
        importance=0.8
    )
    
    # ç”Ÿæˆå€™é€‰è§„å¾‹
    candidate_rules = generator.generate_candidate_rules([test_experience])
    
    print(f"\nç”Ÿæˆäº† {len(candidate_rules)} ä¸ªå€™é€‰è§„å¾‹:")
    
    # æŒ‰ç»„åˆç±»å‹ç»Ÿè®¡
    type_counts = defaultdict(int)
    for rule in candidate_rules:
        type_counts[rule.combination_type.value] += 1
    
    print("\nå„ç»„åˆç±»å‹ç”Ÿæˆæ•°é‡:")
    for combo_type, count in sorted(type_counts.items()):
        print(f"  {combo_type}: {count}")
    
    # æ˜¾ç¤ºå‰10ä¸ªè§„å¾‹ç¤ºä¾‹
    print("\nå‰10ä¸ªå€™é€‰è§„å¾‹ç¤ºä¾‹:")
    for i, rule in enumerate(candidate_rules[:10]):
        print(f"{i+1}. [{rule.combination_type.value}] {rule.condition_text}")
        print(f"   é¢„æœŸç»“æœ: {rule.expected_result}")
        print(f"   è´¨é‡å¾—åˆ†: {rule.calculate_quality_score():.3f}")
        print()
    
    # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    stats = generator.get_statistics()
    print("ç”Ÿæˆç»Ÿè®¡:")
    for key, value in stats['generation_stats'].items():
        print(f"  {key}: {value}")
    
    print("\n=== æµ‹è¯•å®Œæˆ ===")


if __name__ == "__main__":
    test_eocar_combination_generator() 